多线程相关笔记

# 1. 为什么需要并行（多线程）
1. 业务需求
eg: 一个http服务器同一时刻需要去处理多个客户端的请求。 通常的做法是为每个客户端去开启一个线程。
2. 性能需求
由于硬件的原因，芯片发展的计算速度限制（4Hz）,我们为了性能而折中使用的是一个cpu中插入多个芯片（多核）

# 2. 并行重要的几个概念
## 同步和异步
![同步与异步的理解图](https://github.com/zhaodahan/zhao_Note/blob/master/img-storage/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5.JPG)
1. 同步和异步是对方法的调用而言的。如果一个方法是同步的，在时间轴上，同步调用会等待方法的返回。
1. 异步调用他会立即返回(但是这并不表示方法调用已经结束了，而是会在后台起一个线程慢慢的进行方法的执行)。
1. 异步调用在调用后会立即得到方法的返回，并不会做等待，这就表示不会影响调用者后面做什么事。

## 并发和并行
![并发和并行](https://github.com/zhaodahan/zhao_Note/blob/master/img-storage/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C.JPG)
1. 并行指的是两个线程同时执行。
1. 并发指的是两个线程交替执行。
1. 并行存在于多个CPU中，单个CPU只能并发。(虽然这两者的外在表现形式是相同的，我们看到的都是两个任务在同时执行)
***

## 临界区
临界区用来表示一种公共的资源和数据，可以被多个线程使用(所有的线程都能访问临界区)。	临界区需要被保护，同一时间只允许一个线程来访问他。

## 阻塞和非阻塞
1. 阻塞和非阻塞是用来形容多线程间的相互影响。比如： 两个线程都需要使用临界区的资源，一个线程在访问的时候，另一个线程无法访问
另个一个线程被迫等待，这就是阻塞。阻塞的含义是这个线程在操作系统层面别挂起，这就导致阻塞的性能一般不会太好。
	
1. 非阻塞就是允许多个线程同时进入阻塞区(只要保证不把临界区资源弄坏)
	
## 锁 ，饥饿 和活锁
![死锁](https://github.com/zhaodahan/zhao_Note/blob/master/img-storage/%E6%AD%BB%E9%94%81.JPG)
1. 对于阻塞的程序来讲，进入临界区可能发生死锁的情况。如图中四辆车辆发生了死锁，每辆小车锁占有的路线视为资源。每辆车各占一条路，A车需要B车锁占得路，都堵住了无法行走，除非挪走一辆车。------这就是死锁。
	
1. 与死锁对应的就是活锁。就类似电梯遇人的情况。电梯门开了，里面的人要出来，外面的人要进去，两人迎面碰撞，这是，为了下次再相撞，里面的人往左让，外面的人往右让，这是两人又相撞了，这时你发现不对，就往右让，他往左让，因为你们是相对的，如此总是会把门堵住。。。如此反复。-----这就是活锁。(如果是人的话，会停下来，让一个人先过，但是程序不会，他会一直执行)。如果是发生在线程上面的，一个线程如果在抢占到资源后发现另外的资源他无法拿到，(死锁的必要条件是抢占了资源而不释放它，如果抢占了资源释放了它，就不会产生死锁) 因为这时候没有办法拿到所有的资源，这时候为避免死锁，就释放掉已经拿到的资源，然而这时候另外的线程也做了同样的事情。他们需要相同的资源（比如说都需要资源A 和资源B ,这时候一个线程抢占了A,另一个线程抢占了资源B,但是这个时候两个线程都释放了资源，这个时候发现A,B 都有了，又进行新一波的抢占和释放）。这就是活锁，就是资源在线程之间跳来跳去且任务无法继续下去，活锁这样的问题是动态的，死锁是静态问题。
	​	
	
1. 饥饿时在一种情况下： 在等待队列中，一个线程的优先级很低，在线程抢占调度过程总是无法调用到这个线程，就会导致这个线程无法抢占资源而饿死。
	​	
	
## 并发的级别

1. 阻塞
	
1. 非阻塞
	
1. 无障碍 ：最弱的非阻塞调度(和阻塞调度相比，阻塞调度室一种悲观的策略，它会认为大家一起修改数据会导致把数据改坏，所以每次只允许一个人去修改，而非阻塞调度相比而言比较乐观，可以大家一起修改，放开了锁都可以进，但它是一种宽进严出的策略，如果它发现一个线程操作临界区数据与其他线程操作发生了冲突，它会回滚重试)，
	
1. 无锁
无锁是无障碍的升级版，无锁首要条件是无障碍的，它在无障碍的基础上加了一个条件就是保证在临界区的竞争中保证会有一个胜出。(无锁的使用比较广泛)
	
1. 无等待
无锁
	​			
要求所有线程必须在有限步数里完成
	​				
无饥饿
	​				
(无等待的典型案例：所有的线程只是读线程，不是写线程必然是无等待的。）


# 3.并行的两个重要的定律

## 1. Amdahl定律（阿姆达尔定律）
![阿姆达尔定律——加速比](https://github.com/zhaodahan/zhao_Note/blob/master/img-storage/%E9%98%BF%E5%A7%86%E8%BE%BE%E5%B0%94%E5%AE%9A%E5%BE%8B(%E5%8A%A0%E9%80%9F%E6%AF%94).JPG)

阿姆达尔定律定义了串行系统并行化后的加速比( 加速比=优化前系统耗时/优化后系统耗时)--理论上限


## 2. Gustafson定律（古斯塔夫森定律）

只要有足够的并行化，加速比和CPU个数成正比

# 4 多线程基础

（1）Java中线程的概念和操作系统的线程是类似的。事实上Java中会把Java的线程映射到操作系统的线程中去。就是说如果在Java中开启了一个线程就等同于在windows中调用了开启线程的方法。

（2）线程的start() 方法和run() 方法的区别： run() 实现于runnable接口(==每个线程都是runnable接口的一个实现==)，start()只是在一个新的操作系统的线程上去调用run()方法，实际上调用run()而调用start(),两者实质上做的事情都一样start()就是去调用run方法，但是调用run()方法并不会开启一个新的线程，而是在调用的当前线程去执行操作；只有使用了start()才是真的开了一个新的线程。 


(3) 线程的操作
###### 创建

Thread.start() 和run() 方法

###### 终止

Thread.stop()方法(++不推荐使用，这个API太暴力，会导致线程没有执行完的时候就释放了资源，会导致多线程的数据的不一致性++)。

###### 线程的中断

线程中断的三个方法

```
(Thread)
public void interrupt() //中断线程
public Boolean  isInterrupted //判断是否被中断
public static boolean interrupted //判断是否被中断，并清除当前中断状态

```
什么是线程中断？

> 就是在线程运行时，对它打了个招呼，它就会把自己的一个所谓的中断标志位置上。这样他在运行的时候就知道有人需要它在运行的时候做一些响应。这样他就会做一些额外的操作。

> 因为Thread.stop()太过于暴力会影响数据的一致性。可以使用线程的中断来较为温和的停止线程。

==中断并不会让线程执行，他只是打了一个招呼，如果要让线程做额外的操作，需要再额外的填添加一些操作逻辑==

线程中断另一种常用的方法：


```
public static  native void sleep(long milis) throw InterruptedException // 线程休眠
```
如果我们希望一个线程不要走太快我们一般会调用sleep()方法让其休眠几秒钟。

> sleep()等让线程等待方法或抛出InterruptedException。(是因为线程希望在等待的过程中被打招呼中断他也能被结束，因为在等的过程中对业务来说是没有任何意义的，在等的过程中是应该要对别人打招呼作出响应的)。 sleep方法一般是要被try catch的。只有这样，当别人给我打招呼中断的时候才能立即的通过interruptedException来进行响应来做出一些动作。 (==这里需要注意一点抛出interruptedException后会中断异常标记==。--如果是在一个循环中，想要后续的仍能检测到中断标志需要重新调用一次interrupt()方法。如下图
![image](https://github.com/zhaodahan/zhao_Note/blob/master/img-storage/sleep%E4%B8%AD%E6%96%AD.JPG)
)

###### 线程让步

==static== Thread.yield( ) 方法：使当前线程从运行就绪状态。cpu会从众多的可执行态里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到了。

###### 等待线程结束

join() 等待县城结束：
在我们使用多线程的时候我，我们并不知道线程在什么时候执行完了。往往我们希望等到线程结束后，拿到一些信息才能进行下去。（命名为join的原因：两个线程在不同的路上的走，要join加到一条路上就要等另一个走完。a.join()就是要等a线程走完）

join(long milins)等待多少时间

###### 线程的挂起(suspend)和线程的继续执行(resune)

> 当一个线程在执行过程中吗，如果你希望它能暂停一下，可以使用suspend()方法将线程挂起，当你希望线程继续执行的时候可以调用resume()方法让线程继续执行。 ==但是这两个方法不推荐使用==。 不推荐使用的原因是：如果线程加了锁后执行suspend()方法挂起，在调用resume()之前它不会释放临界区的资源，这样会导致其他线程无法获取到临界区资源而无法执行。
如下图：
![image](https://github.com/zhaodahan/zhao_Note/blob/master/img-storage/%e7%ba%bf%e7%a8%8b%e6%b0%b8%e4%b9%85%e8%a2%ab%e6%8c%82%e8%b5%b7.JPG)
在多线程情况下：如果另一线程执行resume()在线程执行suspend()之前，将会导致需要锁的线程被永久挂起。

---
==1.如果安装了jdk，在cmd中可以使用jps命令查看系统中的Java进程
2. 使用jstack pid(进程id) 可以导出该进程的所有线程。==
---

（4） 守护线程
在后台默默的完成一些系统维护（如： 垃圾回收）的一些线程。 一个Java程序中珠现场执行完，不管还有没有守护线程，系统就认为已无用，就会关闭。

Thread t=new Thread();
t.setDeamon(true); //设置线程为守护线程。必须设置在start()之前；

（5）线程的优先级
线程是可以抢占到资源的，优先级高的线程是更有可能抢占到资源的，更快的执行。

```
设置线程优先级的方法是在线程上调用setPriority()设置优先级
```

(6) 线程的同步，通信

多线程执行过程中十分重要的一点就是—多线程之间如何通信。一个线程挂起了，别人怎么来唤醒我。还有几个线程彼此竞争，如何来协调竞争了。

Java对这些情况提供了synchronized 关键字来协调线程竞争

synchronize需要注意的一点就是多个线程一定是要操作同一个锁；（特别是当synchronize加到实力方法上，它锁的对象就是当前执行线程传进来的实例）

![synchronized.png](https://github.com/zhaodahan/zhao_Note/blob/master/img-storage/synchronized.png?raw=true)

~~~java
Java提供Ojbect.wait()  //线程等待在当前对象(Object --synchronized(object)监视器)上
Object.notify() 用于线程通信 //通知等待在object这个对象上的线程从wait()上返回
~~~

也就是说一个线程调用了wait()方法就会进入wait状态，而不会再接着往下执行。

wait()这个方法的执行，必须要获得object这个监视器对象。这个方法的大致做的事情是在内存中建立一个键值对表，object监视器作为key,等待在当前监视器上的线程队列作为value。 这个线程队列中可以存在许多线程。当调用object。notify()的时候，会通过object这个监视器对象作为key，在键值对表中查询出它对应的等待线程队列。 然后随机的竞争一个线程来唤醒。

![wait，notify.JPG](https://github.com/zhaodahan/zhao_Note/blob/master/img-storage/wait%EF%BC%8Cnotify.JPG?raw=true)

在使用这两个方法的时候需要注意

![wait,notify 注意事项.JPG](https://github.com/zhaodahan/zhao_Note/blob/master/img-storage/wait,notify%20%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.JPG?raw=true)

无论是wait()还是notify(),==在调用之前都必须先获得这个监视器的这个锁==，即需要在synchronized 修饰代码块中才能使用。(十分正常的逻辑，你需要先拿到他，才能调用他的方法)。且调用了object.wait()方法后， 线程的会释放object这个监视器的所有权，然后等待其他线程将他唤醒。

# 5 ，无锁

1.什么是无锁？

无锁就是“无障碍”的运行且每次竞争的时候必然会决出一个优胜者。“无障碍” 就是可以任意的访问临界区的资源，不用等待获取锁，多个线程可以同时的进入临界区。

2.无锁的原理：

说到了无锁，那就要说我们为什么要有锁。并发编程的加锁是为了保证共享对象的安全访问。 加锁的本质就是变“并发”为“串行”， 一次只允许一个访问就安全了。 并发变成了串行必然的访问速度的就降低了。 要提高速度就只能不加锁。 无锁由此诞生。

无锁的实现是使用了CAS算法。

3. 什么是CAS算法

CAS（Compare-and-Swap），即比较并替换，是一种实现并发算法时常用到的技术，Java并发包中的很多类都使用了CAS技术。

简而言之： CAS算法就是一种比synchronized关键字更加优秀的能保证并发访问时共享对象安全的策略。

CAS算法

要讲cas算法就要讲无锁

1. 什么是无锁

   相对于线程加锁来保证线程访问临界区的安全访问这种悲观策略。 无锁是一种相对乐观的策略，他认为对临界区的访问不存在冲突，无需阻塞。

2. 无锁的时候多线程共同访问临界区的资源怎么办？

   无锁就是通过CAS比较交换技术来鉴别线程冲突。一旦检测到有异常就会重试当前操作，直到没有异常为止。

CAS的原理

1. 具体内容

   一个CAS方法包含三个参数CAS(V,E,N)。V表示要更新的变量，E表示预期的值，N表示新值。只有当V的值等于E时，才会将V的值修改为N。如果V的值不等于E，说明已经被其他线程修改了，当前线程可以放弃此操作，也可以再次尝试次操作直至修改成功。基于这样的算法，CAS操作即使没有锁，也可以发现其他线程对当前线程的干扰（临界区值的修改），并进行恰当的处理

   说人话就是：CAS算法会在一个线程视图操作临界区变量的值的时候判断一下要修改的值是否是我们需要的预期的值，即它是否被其他的线程给修改了。 否则就重试，直至成功。 CAS算法是cpu指令级的原子操作(避免了异常)。

   **CAS 的含义是“我认为原有的值应该是什么，如果是，则将原有的值更新为新值，否则不做修改，并告诉我原来的值是多少”**。

2. sd

**cas**

 当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新。 其余都失败，失败的不会被挂起，仅被告知失败，并允许再次尝试，和放弃操作。cas只是由一条CPU指令完成，是指令级的操作。



































