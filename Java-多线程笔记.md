多线程相关笔记

# 1. 为什么需要并行（多线程）
1. 业务需求
eg: 一个http服务器同一时刻需要去处理多个客户端的请求。 通常的做法是为每个客户端去开启一个线程。
2. 性能需求
由于硬件的原因，芯片发展的计算速度限制（4Hz）,我们为了性能而折中使用的是一个cpu中插入多个芯片（多核）

# 2. 并行重要的几个概念
## 同步和异步
![同步与异步的理解图](https://github.com/zhaodahan/zhao_Note/blob/master/img-storage/%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5.JPG)
1. 同步和异步是对方法的调用而言的。如果一个方法是同步的，在时间轴上，同步调用会等待方法的返回。
1. 异步调用他会立即返回(但是这并不表示方法调用已经结束了，而是会在后台起一个线程慢慢的进行方法的执行)。
1. 异步调用在调用后会立即得到方法的返回，并不会做等待，这就表示不会影响调用者后面做什么事。

## 并发和并行
![并发和并行](https://github.com/zhaodahan/zhao_Note/blob/master/img-storage/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C.JPG)
1. 并行指的是两个线程同时执行。
1. 并发指的是两个线程交替执行。
1. 并行存在于多个CPU中，单个CPU只能并发。(虽然这两者的外在表现形式是相同的，我们看到的都是两个任务在同时执行)
***
	
## 临界区
临界区用来表示一种公共的资源和数据，可以被多个线程使用(所有的线程都能访问临界区)。	临界区需要被保护，同一时间只允许一个线程来访问他。

## 阻塞和非阻塞
1. 阻塞和非阻塞是用来形容多线程间的相互影响。比如： 两个线程都需要使用临界区的资源，一个线程在访问的时候，另一个线程无法访问
另个一个线程被迫等待，这就是阻塞。阻塞的含义是这个线程在操作系统层面别挂起，这就导致阻塞的性能一般不会太好。
		
1. 非阻塞就是允许多个线程同时进入阻塞区(只要保证不把临界区资源弄坏)
	
## 锁 ，饥饿 和活锁
![死锁](https://github.com/zhaodahan/zhao_Note/blob/master/img-storage/%E6%AD%BB%E9%94%81.JPG)
		对于阻塞的程序来讲，进入临界区可能发生死锁的情况。如图中四辆车辆发生了死锁，每辆小车锁占有的路线视为资源。每辆车各占一条
		路，A车需要B车锁占得路，都堵住了无法行走，除非挪走一辆车。------这就是死锁。
		
		与死锁对应的就是活锁。就类似电梯遇人的情况。电梯门开了，里面的人要出来，外面的人要进去，两人迎面碰撞，这是，为了下次
		再相撞，里面的人往左让，外面的人往右让，这是两人又相撞了，这时你发现不对，就往右让，他往左让，因为你们是相对的，如此
		总是会把门堵住。。。如此反复。-----这就是活锁。(如果是人的话，会停下来，让一个人先过，但是程序不会，他会一直执行)。
		如果是发生在线程上面的，一个线程如果在抢占到资源后发现另外的资源他无法拿到，(死锁的必要条件是抢占了资源而不释放它，
		如果抢占了资源释放了它，就不会产生死锁) 因为这时候没有办法拿到所有的资源，这时候为避免死锁，就释放掉已经拿到的资源，
		然而这时候另外的线程也做了同样的事情。他们需要相同的资源（比如说都需要资源A 和资源B ,这时候一个线程抢占了A,另一个线
		程抢占了资源B,但是这个时候两个线程都释放了资源，这个时候发现A,B 都有了，又进行新一波的抢占和释放）。这就是活锁，就是
		资源在线程之间跳来跳去且任务无法继续下去，活锁这样的问题是动态的，死锁是静态问题。
		
		
		饥饿时在一种情况下： 在等待队列中，一个线程的优先级很低，在线程抢占调度过程总是无法调用到这个线程，就会导致这个线程
		无法抢占资源而饿死。
		
	
## 并发的级别
		
		阻塞
		
		非阻塞
		
		  无障碍 ：最弱的非阻塞调度(和阻塞调度相比，阻塞调度室一种悲观的策略，它会认为大家一起修改数据会导致把数据改坏，所以每次
		            只允许一个人去修改，而非阻塞调度相比而言比较乐观，可以大家一起修改，放开了锁都可以进，但它是一种宽进严出的策
					略，如果它发现一个线程操作临界区数据与其他线程操作发生了冲突，它会回滚重试)，
			        
		  
		  无锁
				无锁是无障碍的升级版，无锁首要条件是无障碍的，它在无障碍的基础上加了一个条件就是保证在临界区的竞争中保证会有一个胜出。
		        (无锁的使用比较广泛)
			 
		  无等待
				无锁
				
				要求所有线程必须在有限步数里完成
				
				无饥饿
				
				（无等待的典型案例：所有的线程只是读线程，不是写线程必然是无等待的。）


# 3.并行的两个重要的定律

   1.Amdahl定律（阿姆达尔定律）
![阿姆达尔定律——加速比](https://github.com/zhaodahan/zhao_Note/blob/master/img-storage/%E9%98%BF%E5%A7%86%E8%BE%BE%E5%B0%94%E5%AE%9A%E5%BE%8B(%E5%8A%A0%E9%80%9F%E6%AF%94).JPG)
   
       阿姆达尔定律定义了串行系统并行化后的加速比( 加速比=优化前系统耗时/优化后系统耗时)--理论上限
   
   2.Gustafson定律（古斯塔夫森定律）















		